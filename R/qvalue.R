# qvalue function by John D. Storey <email: jstorey@u.washington.edu > ,
# modified by Peter Langfelder for use in WGCNA

# qvalue.restricted ####
#' qvalue convenience wrapper
#'
#' This function calls \code{\link{qvalue}} on finite input p-values,
#' optionally traps errors from the q-value calculation, and returns just the q
#' values.
#'
#'
#' @param p a vector of p-values. Missing data are allowed and will be removed.
#' @param trapErrors logical: should errors generated by function
#' \code{\link{qvalue}} trapped? If \code{TRUE}, the errors will be silently
#' ignored and the returned q-values will all be \code{NA}.
#' @param \dots other arguments to function \code{\link{qvalue}}.
#' @return A vector of q-values. Entries whose corresponding p-values were not
#' finite will be \code{NA}.
#' @author Peter Langfelder
#' @seealso \code{\link{qvalue}}
#' @keywords misc
qvalue.restricted <- function(p, trapErrors = TRUE, ...) {
    fin <- is.finite(p)
    qx <- try(qvalue(p[fin], ...)$qvalues, silent = TRUE)
    q <- rep(NA, length(p))
    if (inherits(qx, "try - error")) {
        if (!trapErrors) {
            stop(qx)
        }
    } else {
        q[fin] <- qx
    }
    q
}

# qvalue ####


#' Estimate the q-values for a given set of p-values
#' 
#' Estimate the q-values for a given set of p-values.  The q-value of a test
#' measures the proportion of false positives incurred (called the false
#' discovery rate) when that particular test is called significant.
#' 
#' If no options are selected, then the method used to estimate
#' \eqn{\pi_0}{pi_0} is the smoother method described in Storey and Tibshirani
#' (2003). The bootstrap method is described in Storey, Taylor & Siegmund
#' (2004).
#' 
#' @param p A vector of p-values (only necessary input)
#' @param lambda The value of the tuning parameter to estimate
#' \eqn{\pi_0}{pi_0}. Must be in [0, 1). Optional, see Storey (2002).
#' @param pi0.method Either "smoother" or "bootstrap"; the method for
#' automatically choosing tuning parameter in the estimation of
#' \eqn{\pi_0}{pi_0}, the proportion of true null hypotheses
#' @param fdr.level A level at which to control the FDR. Must be in (0, 1].
#' Optional; if this is selected, a vector of TRUE and FALSE is returned that
#' specifies whether each q-value is less than fdr.level or not.
#' @param robust An indicator of whether it is desired to make the estimate
#' more robust for small p-values and a direct finite sample estimate of pFDR.
#' Optional.
#' @param smooth.df Number of degrees-of-freedom to use when estimating
#' \eqn{\pi_0}{pi_0} with a smoother. Optional.
#' @param smooth.log.pi0 If TRUE and \code{pi0.method} = "smoother",
#' \eqn{\pi_0}{pi_0} will be estimated by applying a smoother to a scatterplot
#' of \eqn{log} \eqn{\pi_0}{pi_0} estimates against the tuning parameter
#' \eqn{\lambda}{lambda}. Optional.
#' @return A list containing: \item{call}{gives the function call}
#' \item{pi0}{an estimate of the proportion of null p-values} \item{qvalues}{a
#' vector of the estimated q-values (the main quantity of interest)}
#' \item{pvalues}{a vector of the original p-values} \item{significant}{if
#' fdr.level is specified, and indicator of whether the q-value fell below
#' fdr.level (taking all such q-values to be significant controls FDR at level
#' fdr.level)}
#' @note This function is adapted from package qvalue. The reason we provide
#' our own copy is that package qvalue contains additional functionality that
#' relies on Tcl/Tk which has led to multiple problems. Our copy does not
#' require Tcl/Tk.
#' @author John D. Storey \email{jstorey@@u.washington.edu}, adapted for WGCNA
#' by Peter Langfelder
#' @references Storey JD. (2002) A direct approach to false discovery rates.
#' Journal of the Royal Statistical Society, Series B, 64: 479-498.
#' 
#' Storey JD and Tibshirani R. (2003) Statistical significance for genome-wide
#' experiments. Proceedings of the National Academy of Sciences, 100:
#' 9440-9445.
#' 
#' Storey JD. (2003) The positive false discovery rate: A Bayesian
#' interpretation and the q-value. Annals of Statistics, 31: 2013-2035.
#' 
#' Storey JD, Taylor JE, and Siegmund D. (2004) Strong control, conservative
#' point estimation, and simultaneous conservative consistency of false
#' discovery rates: A unified approach. Journal of the Royal Statistical
#' Society, Series B, 66: 187-205.
#' @keywords misc
qvalue <- function(p, lambda = seq(0, 0.90, 0.05), pi0.method = "smoother",
                   fdr.level = NULL, robust = FALSE, smooth.df = 3,
                   smooth.log.pi0 = FALSE) {
    #This is just some pre-processing
    if (min(p) < 0 || max(p) > 1) {
        stop("p-values not in valid range.")
    }
    if (length(lambda) > 1 && length(lambda) < 4) {
        stop("If length of lambda greater than 1, you need at ",
             "least 4 values.")
    }
    if (length(lambda) == 1 ) {
        if (lambda < 0 || lambda >= 1) {
            stop("Lambda must be within [0, 1).")
        }
    }
    if (length(lambda) > 1 && (min(lambda) < 0 || max(lambda) >=  1)) {
        stop("Lambda must be within [0, 1).")
    }

    if (!pi0.method %in% c("smoother", "bootstrap")) {
        stop("'pi0.method' must be one of 'smoother' or 'bootstrap'.")
    }
    m <- length(p)
    #These next few functions are the various ways to estimate pi0
    if (length(lambda) == 1) {
        pi0 <- mean(p >=  lambda)/(1-lambda)
        pi0 <- min(pi0, 1)
    } else {
        pi0 <- rep(0, length(lambda))
        for(i in 1:length(lambda)) {
            pi0[i] <- mean(p >=  lambda[i])/(1 - lambda[i])
        }

        if (pi0.method == "smoother") {
            if (smooth.log.pi0){
              pi0 <- log(pi0)
            }
            spi0 <- smooth.spline(lambda, pi0, df = smooth.df)
            pi0 <- predict(spi0, x=max(lambda))$y

            if (smooth.log.pi0){
              pi0 <- exp(pi0)
            }
            pi0 <- min(pi0, 1)
        } else if (pi0.method == "bootstrap") {
            minpi0 <- min(pi0)
            mse <- rep(0, length(lambda))
            pi0.boot <- rep(0, length(lambda))
            for(i in 1:100) {
                p.boot <- sample(p, size = m, replace = TRUE)
                for(i in 1:length(lambda)) {
                    pi0.boot[i] <- mean(p.boot > lambda[i])/(1-lambda[i])
                }
                mse <- mse + (pi0.boot-minpi0)^2
            }
            pi0 <- min(pi0[mse == min(mse)])
            pi0 <- min(pi0, 1)
        }
    }
    if (pi0 <= 0) {
        stop("The estimated pi0 <= 0. Check that you have valid p-values or ",
             "use another lambda method.")
    }
    ## change by Alan:  check for valid fdr.level
    if (!is.null(fdr.level) && (fdr.level <= 0 || fdr.level > 1)) {
        stop("'fdr.level' must be within (0, 1].")
    }
    #The estimated q-values calculated here
    u <- order(p)

    # change by Alan
    # ranking function which returns number of observations less than or equal
    qvalue.rank <- function(x) {
      idx <- sort.list(x)
      fc <- factor(x)
      nl <- length(levels(fc))
      bin <- as.integer(fc)
      tbl <- tabulate(bin)
      cs <- cumsum(tbl)
      tbl <- rep(cs, tbl)
      tbl[idx] <- tbl
      return(tbl)
    }

    v <- qvalue.rank(p)

    qvalue <- pi0*m*p/v
    if (robust) {
        qvalue <- pi0*m*p/(v*(1-(1-p)^m))
    }
    qvalue[u[m]] <- min(qvalue[u[m]], 1)
    for(i in (m-1):1) {
        qvalue[u[i]] <- min(qvalue[u[i]], qvalue[u[i+1]], 1)
    }
    #The results are returned
    if (!is.null(fdr.level)) {
        retval <- list(call = match.call(), pi0 = pi0, qvalues = qvalue,
                       pvalues = p, fdr.level = fdr.level, ## change by Alan
                       significant = (qvalue <= fdr.level), lambda = lambda)
    }
    else {
        retval <- list(call = match.call(), pi0 = pi0, qvalues = qvalue,
                       pvalues = p, lambda = lambda)
    }
    class(retval) <- "qvalue"
    return(retval)
}
