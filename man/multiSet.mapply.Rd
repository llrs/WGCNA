% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multiData.R
\name{multiSet.mapply}
\alias{multiSet.mapply}
\title{Apply a function to elements of given multiSet structures.}
\usage{
multiSet.mapply(FUN, ..., MoreArgs = NULL, mdma.argIsMultiData = NULL,
  mdmaExistingResults = NULL, mdmaUpdateIndex = NULL,
  mdmaSimplify = FALSE, returnList = FALSE, mdma.doCollectGarbage = FALSE,
  mdmaVerbose = 0, mdmaIndent = 0)
}
\arguments{
\item{FUN}{Function to be applied.}

\item{MoreArgs}{A named list that specifies the scalar arguments (if any) to
\code{FUN}.}

\item{mdma.argIsMultiData}{Optional specification whether arguments are
multiSet structures. A logical vector where each component corresponds to
one entry of \code{...}. If not given, multiSet status will be determined
using \code{\link{is.multiSet}} with argument \code{strict=FALSE}.}

\item{mdmaExistingResults}{Optional list that contains previously calculated
results. This can be useful if only a few sets in \code{multiSet} have
changed and recalculating the unchanged ones is computationally expensive.
If not given, all calculations will be performed. If given, components of
this list are copied into the output. See \code{mdmUpdateIndex} for which
components are re-calculated by default.}

\item{mdmaUpdateIndex}{Optional specification of which sets in
\code{multiSet} the calculation should actually be carried out. This
argument has an effect only if \code{mdmaExistingResults} is non-NULL. If
the length of \code{mdmaExistingResults} (call the length `k') is less than
the number of sets in \code{multiSet}, the function assumes that the
existing results correspond to the first `k' sets in \code{multiSet} and
the rest of the sets are automatically calculated, irrespective of the
setting of \code{mdmaUpdateIndex}. The argument \code{mdmaUpdateIndex} can
be used to specify re-calculation of some (or all) of the results that
already exist in \code{mdmaExistingResults}.}

\item{mdmaSimplify}{Logical: should simplification of the result to an array
be attempted? The simplification is fragile and can produce unexpected
errors; use the default \code{FALSE} if that happens.}

\item{returnList}{Logical: should the result be turned into a list (rather
than a multiSet structure)? Note that this is incompatible with
simplification: if \code{mdaSimplify} is \code{TRUE}, this argument is
ignored.}

\item{mdma.doCollectGarbage}{Should garbage collection be forced after each
application of \code{FUN}?}

\item{mdmaVerbose}{Integer specifying whether progress diagnistics should be
printed out. Zero means silent, increasing values will lead to more
diagnostic messages.}

\item{mdmaIndent}{Integer specifying the indentation of the printed progress
messages. Each unit equals two spaces.}

\item{\dots}{Arguments to be vectorized over. These can be multiSet
structures or simple vectors (e.g., lists).}
}
\value{
A multiSet structure containing (as the \code{data} components) the
results of \code{FUN}. If simplification is successful, an array instead.
}
\description{
Inspired by \code{\link{mapply}}, this function applies a given function to
each \code{data} component in the input multiSet arguments, and optionally
simplify the result to an array if possible.
}
\details{
A multiSet structure is intended to store (the same type of) data for
multiple, possibly independent, realizations (for example, expression data
for several independent experiments). It is a list where each component
corresponds to an (independent) data set. Each component is in turn a list
that can hold various types of information but must have a \code{data}
component. In a "strict" multiSet structure, the \code{data} components are
required to each be a matrix or a data frame and have the same number of
columns. In a "loose" multiSet structure, the \code{data} components can be
anything (but for most purposes should be of comparable type and content).

This function applies the function \code{FUN} to each \code{data} component
of those arguments in \code{...} that are multiSet structures in the
"loose" sense, and to each component of those arguments in \code{...} that
are not multiSet structures.
}
\examples{
data1 <- matrix(rnorm(100L), 20L, 5L)
data2 <- matrix(rnorm(50L), 10L, 5L)
colnames(data1) <- LETTERS[1:5]
colnames(data2) <- LETTERS[2:6]
md <- list2multiSet(list(Set1 = data1, Set2 = data2))
multiSet.mapply(md, FUN = sum)
}
\author{
Peter Langfelder
}
\seealso{
\code{\link{multiSet}} to create a multiSet structure

\code{multiSet.apply} for application of a function to a single multiSet
structure.
}
\keyword{misc}

